# make a signatures "module" which can use different ways to fit the mutations

#' Fit mutational signatures to a mutation matrix
#'
#' @param mm mutation matrix generated by the function \code{\link{muts_to_mat}}. Rownames are 96-trinucleotides,
#' and colnames are sampleIDs
#' @param signatures 96 x N numeric matrix. Rownames are 96-trinucleotide categories, and colnames are signature names
#' @param method Method either one of "MutationalPatterns_strict",  "MutationalPatterns" , "siglasso", "MuSiCal"
#'
#' @returns  data frame with sampleID column indicating the sampleID, and numeric columns indicating the contribution of
#' each signature to the total number of mutations.
#' @export
#'
#' @examples
fit_muts_to_sigs = function(mm , signatures, method) {

  # check if the Bioconductor R package MutationalPatterns is installed, if not give a warning
  if (grepl("MutationalPatterns", method)) {
    if (!requireNamespace("MutationalPatterns", quietly = TRUE)) {
      stop("Package 'MutationalPatterns' is required for signature refitting.
              Install using Bioconductor")
    }
  }

  if (method == "MutationalPatterns") {

    fit_res = MutationalPatterns::fit_to_signatures(mm, signatures) # perform stricter refitting of the mutatonal signatures

    sig_contribution = fit_res$contribution |>
      t() |>
      as.data.frame() |>
      rownames_to_column("sampleID")
  } else  if (method == "MutationalPatterns_strict") {

    fit_res = MutationalPatterns::fit_to_signatures_strict(mm, signatures) # perform stricter refitting of the mutatonal signatures
    fit_res = fit_res$fit_res

    sig_contribution = fit_res$contribution |>
      t() |>
      as.data.frame() |>
      rownames_to_column("sampleID")

  } else if (method == "siglasso") {

    library(siglasso)
    sig_fit = siglasso::siglasso(mm, signatures) # perform stricter refitting of the mutational signatures
    signature_contributions = sig_fit |> t()
    signature_contributions_all = signature_contributions * colSums(mm)

    sig_contribution = signature_contributions_all |>
      as.data.frame() |>
      rownames_to_column("sampleID")
  } else  if (method == "MuSiCal") {

    library(reticulate)
    use_condaenv("python37_musical", required = TRUE)
    musical <- reticulate::import("musical")
    np <- reticulate::import("numpy")

    mm_np = data.frame(mm)
    signatures_np = data.frame(signatures)
    refit = musical$refit$refit(mm_np, signatures_np)

    sig_contribution = refit[[1]] |>
      t() |>
      as.data.frame()  |>
      rownames_to_column("sampleID")
  }  else  if (method == "MuSiCal_LLB") {

    library(reticulate)
    use_condaenv("python37_musical", required = TRUE)
    musical <- reticulate::import("musical")
    np <- reticulate::import("numpy")

    mm_np = data.frame(mm)
    signatures_np = data.frame(signatures)
    refit = musical$refit$refit(mm_np, signatures_np, method = "likelihood_bidirectional", thresh = 0.001)

    sig_contribution = refit[[1]] |>
      t() |>
      as.data.frame()  |>
      rownames_to_column("sampleID")
  } else {
    stop(paste("Method must be one of the following:", "MutationalPatterns,", "MutationalPatterns_strict,", "siglasso,", "MuSiCal", "MuSiCal_LLB"))

  }

  return(sig_contribution)
}


#' Fit multiple signature methods
#'
##' @description
#' Wrapper for the function \code{\link{muts_to_mat}} to run for multiple method.
#' Runs the methods:
#'  -  \link[MutationalPatterns::fit_to_signatures]{fit_to_signatures}
#'  -  \link[MutationalPatterns::fit_to_signatures_strict]{fit_to_signatures_strict}
#'  -  \link[siglasso::siglasso]{siglasso}
#'  -  \href{https://github.com/parklab/MuSiCal}{MuSiCal}
#'
#' @param mm mutation matrix generated by the function \code{\link{muts_to_mat}}. Rownames are 96-trinucleotides, and colnames are sampleIDs
#' @param signatures Matrix containing the signature vectors. Format: 96 x N numeric matrix. Rownames are 96-trinucleotide categories
#'  and colnames are signature names
#'
#' @returns Signature contributions
#' @export
#'
#' @examples
fit_all_sig_methods = function(mm, signatures) {

  result_list = list()
  for (method in c("MutationalPatterns", "MutationalPatterns_strict", "siglasso", "MuSiCal", "MuSiCal_LLB")) {

    print(method)

    result_list[[method]] = fit_muts_to_sigs(mm, signatures, method = method)
  }

  # script to run tests:
  signature_refits = rbindlist(result_list, idcol = "method")

  signature_refits = signature_refits |>
    mutate(total = rep(colSums(mm), 5)) |>
    rowwise() |>
    mutate(unassigned = total - sum(c_across(starts_with("SBS")))) |>
    ungroup()
}

#' Plot the mutational signature contribution
#'
#' @param signature_refits Output of \link{fit_all_sig_methods}
#'
#' @returns barplot with the contribution of the different signatures
#' @export
#'
#' @examples
plot_sig_extraction_methods = function(signature_refits) {
  sig_names = signature_refits |> dplyr::select(starts_with("SBS")) |>
    colnames()
  signature_refits_long = signature_refits |>
    pivot_longer(-c(method, sampleID, total), names_to = "signature")  |>
    mutate(signature = factor(signature, levels = c("unassigned", sig_names)))

  signature_refits_long |>
    ggplot(aes(x = sampleID, y = value, fill = signature)) +
    geom_col() +
    facet_grid(method ~ . ) +
    scale_fill_manual(values = sig_colors) +
    scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
    cowplot::theme_cowplot() +
    theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(), strip.clip = "off",
          strip.text.y = element_text(size = 9)) +
    labs(y = "number of SBS mutations")
}

#' Compare signature refits to mutation profiles
#' @description
#' Function returns a boxplot indicating the cosine similarity of the original
#' 96-trinucleotide profile (given as "mm") and the reconstructed profile (signatures x contribution)
#'
#'
#' @param signature_refits Output of \link{fit_all_sig_methods}
#' @param signatures Matrix containing the signature vectors. Format: 96 x N numeric matrix. Rownames are 96-trinucleotide categories
#'  and colnames are signature names
#' @param mm
#'
#' @returns
#' @export
#'
#' @examples
cos_sim_reconstructed_methods = function(signature_refits, signatures, mm) {

  sig_contribution = signature_refits |> select(starts_with("SBS"))  |> as.matrix()
  sig_names = colnames(sig_contribution)

  signature_refits$cos_sim_recostructed = NA

  for (i in 1:nrow(sig_contribution)) {
    sampleID = signature_refits[i, ] |> pull(sampleID)
    signature_refits$cos_sim_recostructed[i] = cos_sim(colSums(sig_contribution[i,] * t(signatures[,sig_names])), mm[,sampleID])
  }

  mean_refit = signature_refits |>
    group_by(method) |>
    summarize(mean = mean(cos_sim_recostructed),
              label = format(mean, digits = 4))

    signature_refits |>
    ggplot(aes(x = method)) +
    geom_boxplot(aes(y = cos_sim_recostructed), outliers = FALSE) +
    ggbeeswarm::geom_quasirandom(aes(y = cos_sim_recostructed), size = 0.2) +
    geom_text(data = mean_refit, mapping = aes(y = 1, label = paste0("mean:\n",label)), vjust = 0) +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
    scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
    labs(x = NULL, y = "cosine similarity reconstructed")
}


#' Comparing the similarities of the signature refits
#'
#'
#' @description Wrapper for the function \link[MutationalPatterns::cos_sim_matrix]{cos_sim_matrix} to
#' compare signature refitting methods.
#' The input of the function is the signature contribution resulting from \link{fit_all_sig_methods}
#' and resulting in a heatmap plot indicating the similarity between the signature refitting methods.
#'
#' @param signature_refits Output of \link{fit_all_sig_methods}
#'
#' @returns Heatmap indicating the cosine similarity values of the
#' @export
#'
#' @examples
compare_contribution_cosine = function(signature_refits) {
  df = signature_refits |>
    select(-sampleID, -total) |>
    pivot_longer(-method) |>
    select(-name)

  split_list = split(df, df$method)
  split_list = lapply(split_list, \(x) x$value)

  df = data.frame(split_list)

  cosine_matrix = MutationalPatterns::cos_sim_matrix(df, df)

  cosine_matrix |>
    as.data.frame() |>
    rownames_to_column("method") |>
    pivot_longer(-method) |>
    ggplot(aes(method, name)) +
    geom_tile(aes(fill = value)) +
    geom_text(aes(label = round(value, 3))) +
    scale_fill_gradient(low = "white", high = "red") +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
    labs(x = NULL, y = NULL)
}
